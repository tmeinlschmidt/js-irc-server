var _ = require('underscore-min'),
    ChanServ = require('chanserv'),
    Parse = require('parse'),
    CmdLine = new Parse.CommandLine,
    _const = require('irc-constants')

var IrcServer = function() {
  this._socket = null;
  this._channels = {};
  this._clients = {};
  this.buffer = null;
  this._version = '0.0.1';
  this._usermodes = 'aio'; // away, invisible, op
  this._channelmodes = 'okpst'; // op, password, private, secret, topic
  this.motd = "this is message of the day \n\
and it could continue to next lines \n\
and next line. Welcome all here! :) ";
  this._chanserv = new ChanServ(this);
}

// set up new IRC client 
IrcServer.prototype.newClient = function(socket, motd) {
  this._clients[socket.remotePort] = {};
  this._clients[socket.remotePort]['socket'] = socket;
  this._clients[socket.remotePort]['nick'] = null;
  this._clients[socket.remotePort]['pass'] = null;
  this._clients[socket.remotePort]['user'] = null;
  this._clients[socket.remotePort].logged = false;
  this._socket = this._clients[socket.remotePort];
  if (motd) this._sendNotice();
}

// send message to current socket
IrcServer.prototype.send = function(msg) {
  this.sendToSocket(this._socket.socket, msg);
}

// write to specified socket
IrcServer.prototype.sendToSocket = function(socket, msg) {
  socket.write(msg);
}

// User ----

// find connected user by nickname
IrcServer.prototype._findUser = function(nick, raise_error) {
  var user = _.find(this._clients, function(val) {
    return (val.nick == nick)
  });
  if (user != undefined) return user;
  if (raise_error) {
    // not found
    this.sendClientMessage(_const.errors.ERR_NOSUCHNICK, ':No such nick/channel');
  }
  return false;
}

// {{{ Commands

// QUIT
IrcServer.prototype._quit = function(params) {
  this._removeUserFromChannels(params);
  this._socket.socket.end();
}

// JOIN <channel>[ | <modes> ] *( "," <channel>[ | <modes> ] )
IrcServer.prototype._join = function(params) {
  if (!this._requireLogin()) return false;

  if (this._addUserToChannel(params.options, this._socketPort())) {
    // success - joined
  } else {
    // failure
  }
}

// ISON <nick> ..
IrcServer.prototype._ison = function(params) {
  _.reject(params.options, function(client) {
    return (this._findUser(client, false) === false);
  }, this);
  if (params.options.size>0) {
    this.sendClientMessage(_const.reply.RPL_ISON, ':'+params.options.join(' '));
  }
}

// CAP
IrcServer.prototype._cap = function(params) {
  switch(params.options[0]) {
    case 'LS':
      this.sendClientMessage('CAP', 'LS', ':multi-prefix');
      break;
    case 'REQ':
      this.sendClientMessage('CAP', 'ACK', params.options[1]);
      break;
  }
}

// PING
// just return what it's requesting, don't check hostname
IrcServer.prototype._ping = function(params) {
  this.sendClientMessage('PONG', params.options[0], ':'+params.options[0]);
}

// PASS <password> <version> <flags> [<options>]
// supports <password> only
IrcServer.prototype._pass = function(params) {
  // check options and send 
  if (params.options.length == 0) {
    this.sendClientMessage(_const.errors.ERR_NEEDMOREPARAMS, 'PASS', ':Not enough parameters');
    return;
  }
  this._socket.pass = params.options[0];
  this._validateUser();
}

// NICK <nickname> <hopcount> <username> <host> <servertoken> <umode> <realname>
// supports <nickname> only
IrcServer.prototype._nick = function(params) {
  // check options and send 
  if (params.options.length == 0) {
    this.sendClientMessage(_const.errors.ERR_NEEDMOREPARAMS, 'NICK', ':Not enough parameters');
    return;
  }
  // disallow to use ChanServ and filter invalid nick
  if (params.options[0].match(/chanserv/i) != null || 
      params.options[0].match(/^[^a-z]|[^\w_^`\\\[\]{}]/i) != null) {
    this.sendClientMessage(_const.errors.ERR_ERRONEUSNICKNAME, params.options[0], ':Erroneous Nickname');
    return false;
  }
  this._socket.nick = params.options[0];
  this._validateUser();
}

// USER <user> <mode> <unused> <realname>
IrcServer.prototype._user = function(params) {
  
  // forbid reregister
  if (this._socket.user != null) {
    this.sendClientMessage(_const.errors.ERR_ALREADYREGISTRED, ':Unauthorized command (already registered)');
    return;
  }

  // check options and send 
  if (params.options.length != 3 || params.message === '') {
    this.sendClientMessage(_const.errors.ERR_NEEDMOREPARAMS, 'USER', ':Not enough parameters');
    return;
  }

  this._socket.user = params.options[0];
  this._validateUser();
}


// TOPIC <channel> [<topic>]
IrcServer.prototype._topic = function(params) {
  if (!this._requireLogin()) return false;
  
  var user = this._socketPort();
  var channel = this._getChannel(params.options[0], user);
  if (channel === false) return;

  // when locked topic, allow change to operator only
  if (this._hasMode(channel.mode, 't') && !this._hasMode(channel.users[user].mode, 'o')) {
    return false;
  }
  channel.topic = params.options[1] || params.message
  this.sendChannelMessage(channel, 'TOPIC', channel.name, ':' + channel.topic);
}

// PRIVMSG <msgtarget> <message>
IrcServer.prototype._privmsg = function(params) {
  if (!this._requireLogin()) return false;

  if (this.isChannel(params.options[0])) {
    // msg to channel
    var channel = this._getChannel(params.options[0], null);
    if (channel === false) return;
    this.sendChannelMessage(channel, 'PRIVMSG', channel.name, ':' + params.message);
  } else {
    if (params.options[0].match(/chanserv/i) != null) {
      params.options.shift();
      // add message and split again
      params.options = (params.options.join(' ')+params.message).split(/ /);
      this._chanserv.process(params.options);
      return;
    }
    // msg to user
    var user = this._findUser(params.options[0], true);
    if (user === false) return;
    this.sendPrivateClientMessage(user, 'PRIVMSG', this._socket.nick, ':' + params.message);
  }
}

// MOTD [<server>]
IrcServer.prototype._motd = function(params) {
  this.sendClientMessage(_const.reply.RPL_MOTDSTART, ':- ' + this.serverAddr()+ ' Message of the Day -');
  _.each(this.motd.split("\n"), function(line) {
    this.sendClientMessage(_const.reply.RPL_MOTD, ':- '+line);
  }, this);
  this.sendClientMessage(_const.reply.RPL_ENDOFMOTD, ':End of /MOTD command.');
}

// LIST [<channels> [<server>]]
IrcServer.prototype._list = function(params) {
  if (!this._requireLogin()) return false;
  _.each(this._channels, function(channel) {
    if (!this._hasMode(channel.mode, 's')) {
      this.sendClientMessage(_const.reply.RPL_LIST, channel.name, _.size(channel.users), ':' + (channel.topic || ''));
    }
  }, this);
}

// KICK <channel> <client> [<message>]
IrcServer.prototype._kick = function(params) {
  if (!this._requireLogin()) return false;
}

// MODE <nickname> <flags> (user)
// MODE <channel> <flags> [<args>]
// FIXME
IrcServer.prototype._mode = function(params) {
  if (!this._requireLogin()) return false;
  if (this.isChannel(params.options[0])) {
    // for channel
    var channel = this._getChannel(params.options[0], this._socketPort());
    if (channel === false) return;
    params.options.shift();
    /* TODO
    var mode = params.options[0][1];
    var op = params.options[0][0];
    switch(mode) {
      case 'k': this.channel_mode.password(channel, params);break;
      default:
        this.sendClientMessage(_const.errors.ERR_UMODEUNKNOWNFLAG, channel.name, ':Unknown MODE flag');
        return;
    }
    
    this.sendChannelMessage(channel, 'MODE', channel.name, ':' + channel.topic);
    */
  } else {
    this.sendClientMessage(_const.errors.ERR_UMODEUNKNOWNFLAG, params.options[0], ':Unknown MODE flag');
    // for user
  }
}

// VERSION [<server>]
IrcServer.prototype._version = function(params) {
  if (!this._requireLogin()) return false;
  
  this.sendClientMessage(_const.reply.RPL_VERSION, this._version+'.0', this.serverAddr(), ':sample irc server"');
}

// WHO [<name> ["o"]]
IrcServer.prototype._who = function(params) {
  if (!this._requireLogin()) return false;
  this._notImplemented();
}

// AWAY [<message>]
IrcServer.prototype._away = function(params) {
  if (!this._requireLogin()) return false;
  this._notImplemented();
  // set message and user flag +a
}

// PART <channel> [<message>]
IrcServer.prototype._part = function(params) {
  if (!this._requireLogin()) return false;
  this._removeUserFromChannel(params, this._socketPort());
}

// validate user (was password validation here)
IrcServer.prototype._validateUser = function() {
  this._socket.logged = false;
  if (this._socket.nick !== null &&
      this._socket.user !== null) {
    this._socket.logged = true;
    // send welcome screen
    this._sendWelcome();
    this._motd(null);
  }
}
// }}}

// not implemented message
IrcServer.prototype._notImplemented = function() {
  this.sendClientMessage('NOTICE',':Not implemented');
}

// welcome message
IrcServer.prototype._sendWelcome = function() {
  this.sendClientMessage(_const.reply.RPL_WELCOME, ':Welcome to the Internet Relay Network', this._userAddress());
  this.sendClientMessage(_const.reply.RPL_YOURHOST, ':Your host is',this.serverAddr(),', running version', this._version);
  this.sendClientMessage(_const.reply.RPL_CREATED, ':This server was created 20120730');
  this.sendClientMessage(_const.reply.RPL_MYINFO, this.serverAddr(), this._version, this._usermodes, this._channelmodes);
}

// send initial notice
IrcServer.prototype._sendNotice = function() {
  this.sendClientMessage('NOTICE', ":*** Looking up your hostname...");
  this.sendClientMessage('NOTICE', ":*** Checking Ident");
  this.sendClientMessage('NOTICE', ":*** Couldn't look up your hostname");
  this.sendClientMessage('NOTICE', ":*** No Ident response");
}

// get user full address
IrcServer.prototype._userAddress = function() {
  return this._socket.nick+'!~'+this._socket.user+'@'+this._socket.socket.remoteAddress;
}

// is current socket logged in?
IrcServer.prototype._isUserLoggedIn = function() {
  return this._socket.logged;
}

// require login
IrcServer.prototype._requireLogin = function() {
  if (this._isUserLoggedIn()) return true;
  this.sendClientMessage(_const.errors.ERR_NOTREGISTERED, ':You have not registered');
  return false;
}

// Channel operations ----

// get channel
IrcServer.prototype._getChannel = function(_channel, user) {
  
  var channel = this._channels[_channel];
  if (!this._channelExists(_channel)) {
    this.sendClientMessage(_const.errors.ERR_NOSUCHCHANNEL, _channel, ':No such channel'); 
    return false;
  }
  
  // when user !== null, check user presence
  if (user !== null) {
    if (!this._isUserInChannel(channel, user)) {
      this.sendClientMessage(_const.errors.ERR_NOTONCHANNEL, _channel, ":You're not on that channel"); 
      return false;
    }
  }

  return channel;
}

// find or create new channel and set initial params
IrcServer.prototype._findOrCreateChannel = function(channel) {
  // doesn't exist, create basic structure
  if (this._channelExists(channel) === false) {
    this._channels[channel] = {
      "mode" : '', "name" : channel, "topic" : "", "users" : {}, "password": ''
    };
  }
  return this._channels[channel];
}

// add user to existing channel
IrcServer.prototype._addUserToChannel = function(options, user) {
  var chan = this._findOrCreateChannel(options[0]);
  
  // here we can check permissions (or password)
  // private/secret channel
  if (this._hasMode(chan.mode, 'p') || this._hasMode(chan.mode,'s')) {
    // private / secret channel
    return false;
  }
  if (this._hasMode(chan.mode, 'k') && (options.size === 1 || options[1] !== chan.password)) {
    // invalid password
    return false;
  }

  // new channel, set user as op
  var mode = (_.size(chan.users) === 0) ? 'o' : '';
  chan.users[user] = {}
  chan.users[user].mode = mode;
  chan.users[user].socket = this._socket.socket.remotePort;
  
  this.sendChannelMessage(chan, 'JOIN', chan.name);
  
  return true;
}

// remove user from all his channel
IrcServer.prototype._removeUserFromChannels = function(params) {
  _.each(this._channels, function(channel) {
    params.options[0] = channel.name;
    this._removeUserFromChannel(params, this._socketPort());
  }, this);
}

// remove user from particular channel
IrcServer.prototype._removeUserFromChannel = function(params, user) {
  var chan = this._channels[params.options[0]];
  if (!this._isUserInChannel(chan, user)) return false;
  this.sendChannelMessage(chan, 'PART', chan.name, (params.message) ? ':'+params.message : '')
  // remove user
  return delete chan.users[user];
}

// is user in channel?
IrcServer.prototype._isUserInChannel = function(channel, user) {
  return (user in channel.users);
}

// does channel exist?
IrcServer.prototype._channelExists = function(channel) {
  return (this._channels[channel] != undefined && (channel in this._channels))
}

// is string channel?
IrcServer.prototype.isChannel = function(channel) {
  return (channel[0] == '#');
}

// Utils ----

// test mode (if contains)
IrcServer.prototype._hasMode = function(modes, mode) {
  return (modes.match(mode) !== null);
}

// +mode
IrcServer.prototype._setMode = function(modes, mode) {
  return this._unsetMode(modes, mode)+mode;
}

// -mode
IrcServer.prototype._unsetMode = function(modes, mode) {
  return modes.replace(mode, '');
}

// is empty object?
IrcServer.prototype.isEmptyObject = function( obj ) {
  for ( var name in obj ) {
    return false;
  }
  return true;
}

// get client port
IrcServer.prototype._socketPort = function() {
  return this._socket.socket.remotePort;
}

// get server address
IrcServer.prototype.serverAddr = function() {
  return this._socket.socket.address().address;
}

// Messages | Errors ----

// send message to client from server
IrcServer.prototype.sendClientMessage = function(args) {
  var params = Array.prototype.slice.call(arguments);
  
  var error = params[0];
  params.shift();
  
  var messages = params.join(' ') + "\r\n";

  this.send(":" + this.serverAddr() + ' ' + error + ' ' + (this._socket.nick || '*') + ' ' + messages);
}

// send private message to user
IrcServer.prototype.sendPrivateClientMessage = function(args) {
  var params = Array.prototype.slice.call(arguments);
  
  var user = params[0];
  params.shift();
  var cmd = params[0];
  params.shift();
  
  var messages = params.join(' ') + "\r\n";

  this.sendToSocket(user.socket, ':' + this._userAddress() + ' ' + cmd + ' ' + messages);
}

// send message to all users in a channel
IrcServer.prototype.sendChannelMessage = function(args) {
  var params = Array.prototype.slice.call(arguments);
  
  var channel = params[0];
  params.shift();
  var cmd = params[0];
  params.shift();
  
  var messages = params.join(' ') + "\r\n";
  
  _.each(channel.users, function(user, socket) {
    // when private, dont' repeat for sender
    skip = false
    if (cmd == 'PRIVMSG' && socket == this._socketPort()) skip = true;
    if (!skip) {
      this.sendToSocket(this._clients[socket].socket, ':' + this._userAddress() + ' ' + cmd + ' ' + messages);
    }
  }, this);
}

// fetch data to buffer and process
IrcServer.prototype.parseData = function(data, socket) {
  var line, lines, i;

  data = data.replace("\r\n", "\n");
  this.buffer += data;
  lines = this.buffer.split("\n");
  this.buffer = "";

  /* Put the last line back in the buffer if it was incomplete */
  if (lines[lines.length - 1] !== '') {
    this.buffer = lines[lines.length - 1];
  }

  /* Remove the final \n or incomplete line from the array */
  lines = lines.splice(0, lines.length - 1);
  for (i = 0; i < lines.length; i++) {
    line = lines[i];
    this.handleData(line, socket);
  }
}

// handle buffer data
IrcServer.prototype.handleData = function(line, socket) {
  CmdLine.parse(line);
  this.handleRequest(socket, CmdLine);
}

// handle processed buffer data - parsed
IrcServer.prototype.handleRequest = function(socket, params) {
  this._socket = this._clients[socket.remotePort];

  switch (params.command) {
    case 'JOIN':    this._join(params);break;
    case 'PASS':    this._pass(params);break;
    case 'NICK':    this._nick(params);break;
    case 'USER':    this._user(params);break;
    case 'TOPIC':   this._topic(params);break;
    case 'PRIVMSG': this._privmsg(params);break;
    case 'QUIT':    this._quit(params);break;
    case 'MOTD':    this._motd(params);break;
    case 'MODE':    this._mode(params);break;
    case 'LIST':    this._list(params);break;
    case 'KICK':    this._kick(params);break;
    case 'VERSION': this._version(params);break;
    case 'WHO':     this._who(params);break;
    case 'PART':    this._part(params);break;
    case 'CAP':     this._cap(params);break;
    case 'PING':    this._ping(params);break;
    case 'ISON':    this._ison(params);break;
    default:
      this.sendClientMessage(_const.errors.ERR_UNKNOWNCOMMAND, params.command, ':Unknown command');
  }
};

module.exports = IrcServer
